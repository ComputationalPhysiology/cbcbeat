
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1. cbcbeat package &#8212; cbcbeat 1.0 documentation</title>
    
  <link href="_static/css/theme.css" rel="stylesheet">
  <link href="_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    
  <link rel="preload" as="script" href="_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="1.1.1. cbcbeat.cellmodels package" href="cbcbeat.cellmodels.html" />
    <link rel="prev" title="cbcbeat: an adjoint-enabled framework for computational cardiac electrophysiology" href="index.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
      
      
      <h1 class="site-logo" id="site-title">cbcbeat 1.0 documentation</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active has-children">
  <a class="current reference internal" href="#">
   1. cbcbeat package
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="cbcbeat.cellmodels.html">
     1.1.1. cbcbeat.cellmodels package
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/cbcbeat.rst.txt"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.rst</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#subpackages">
   1.1. Subpackages
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#submodules">
   1.2. Submodules
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-cbcbeat.bidomainsolver">
   1.3. cbcbeat.bidomainsolver module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-cbcbeat.cardiacmodels">
   1.4. cbcbeat.cardiacmodels module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-cbcbeat.cellsolver">
   1.5. cbcbeat.cellsolver module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-cbcbeat.dolfinimport">
   1.6. cbcbeat.dolfinimport module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cbcbeat-gossplittingsolver-module">
   1.7. cbcbeat.gossplittingsolver module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cbcbeat-gotran2cellmodel-module">
   1.8. cbcbeat.gotran2cellmodel module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cbcbeat-gotran2dolfin-module">
   1.9. cbcbeat.gotran2dolfin module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-cbcbeat.markerwisefield">
   1.10. cbcbeat.markerwisefield module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-cbcbeat.monodomainsolver">
   1.11. cbcbeat.monodomainsolver module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-cbcbeat.splittingsolver">
   1.12. cbcbeat.splittingsolver module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-cbcbeat.utils">
   1.13. cbcbeat.utils module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-cbcbeat">
   1.14. Module contents
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="cbcbeat-package">
<h1><span class="section-number">1. </span>cbcbeat package<a class="headerlink" href="#cbcbeat-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2><span class="section-number">1.1. </span>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="cbcbeat.cellmodels.html">1.1.1. cbcbeat.cellmodels package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="cbcbeat.cellmodels.html#submodules">1.1.1.1. Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="cbcbeat.cellmodels.html#module-cbcbeat.cellmodels.beeler_reuter_1977">1.1.1.2. cbcbeat.cellmodels.beeler_reuter_1977 module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cbcbeat.cellmodels.html#module-cbcbeat.cellmodels.cardiaccellmodel">1.1.1.3. cbcbeat.cellmodels.cardiaccellmodel module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cbcbeat.cellmodels.html#module-cbcbeat.cellmodels.fenton_karma_1998_BR_altered">1.1.1.4. cbcbeat.cellmodels.fenton_karma_1998_BR_altered module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cbcbeat.cellmodels.html#module-cbcbeat.cellmodels.fenton_karma_1998_MLR1_altered">1.1.1.5. cbcbeat.cellmodels.fenton_karma_1998_MLR1_altered module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cbcbeat.cellmodels.html#module-cbcbeat.cellmodels.fitzhughnagumo">1.1.1.6. cbcbeat.cellmodels.fitzhughnagumo module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cbcbeat.cellmodels.html#module-cbcbeat.cellmodels.fitzhughnagumo_manual">1.1.1.7. cbcbeat.cellmodels.fitzhughnagumo_manual module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cbcbeat.cellmodels.html#module-cbcbeat.cellmodels.grandi_pasqualini_bers_2010">1.1.1.8. cbcbeat.cellmodels.grandi_pasqualini_bers_2010 module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cbcbeat.cellmodels.html#module-cbcbeat.cellmodels.nocellmodel">1.1.1.9. cbcbeat.cellmodels.nocellmodel module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cbcbeat.cellmodels.html#module-cbcbeat.cellmodels.rogers_mcculloch_manual">1.1.1.10. cbcbeat.cellmodels.rogers_mcculloch_manual module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cbcbeat.cellmodels.html#module-cbcbeat.cellmodels.tentusscher_2004_mcell">1.1.1.11. cbcbeat.cellmodels.tentusscher_2004_mcell module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cbcbeat.cellmodels.html#module-cbcbeat.cellmodels.tentusscher_2004_mcell_cont">1.1.1.12. cbcbeat.cellmodels.tentusscher_2004_mcell_cont module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cbcbeat.cellmodels.html#module-cbcbeat.cellmodels.tentusscher_2004_mcell_disc">1.1.1.13. cbcbeat.cellmodels.tentusscher_2004_mcell_disc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cbcbeat.cellmodels.html#module-cbcbeat.cellmodels.tentusscher_panfilov_2006_M_cell">1.1.1.14. cbcbeat.cellmodels.tentusscher_panfilov_2006_M_cell module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cbcbeat.cellmodels.html#module-cbcbeat.cellmodels.tentusscher_panfilov_2006_epi_cell">1.1.1.15. cbcbeat.cellmodels.tentusscher_panfilov_2006_epi_cell module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cbcbeat.cellmodels.html#module-cbcbeat.cellmodels">1.1.1.16. Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2><span class="section-number">1.2. </span>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-cbcbeat.bidomainsolver">
<span id="cbcbeat-bidomainsolver-module"></span><h2><span class="section-number">1.3. </span>cbcbeat.bidomainsolver module<a class="headerlink" href="#module-cbcbeat.bidomainsolver" title="Permalink to this headline">¶</a></h2>
<p>These solvers solve the (pure) bidomain equations on the form: find
the transmembrane potential <span class="math notranslate nohighlight">\(v = v(x, t)\)</span> and the extracellular
potential <span class="math notranslate nohighlight">\(u = u(x, t)\)</span> such that</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}v_t - \mathrm{div} ( G_i v + G_i u) = I_s\\\mathrm{div} (G_i v + (G_i + G_e) u) = I_a\end{aligned}\end{align} \]</div>
<p>where the subscript <span class="math notranslate nohighlight">\(t\)</span> denotes the time derivative; <span class="math notranslate nohighlight">\(G_x\)</span>
denotes a weighted gradient: <span class="math notranslate nohighlight">\(G_x = M_x \mathrm{grad}(v)\)</span> for
<span class="math notranslate nohighlight">\(x \in \{i, e\}\)</span>, where <span class="math notranslate nohighlight">\(M_i\)</span> and <span class="math notranslate nohighlight">\(M_e\)</span> are the
intracellular and extracellular cardiac conductivity tensors,
respectively; <span class="math notranslate nohighlight">\(I_s\)</span> and <span class="math notranslate nohighlight">\(I_a\)</span> are prescribed input. In
addition, initial conditions are given for <span class="math notranslate nohighlight">\(v\)</span>:</p>
<div class="math notranslate nohighlight">
\[v(x, 0) = v_0\]</div>
<p>Finally, boundary conditions must be prescribed. For now, this solver
assumes pure homogeneous Neumann boundary conditions for <span class="math notranslate nohighlight">\(v\)</span> and
<span class="math notranslate nohighlight">\(u\)</span> and enforces the additional average value zero constraint
for u.</p>
<dl class="py class">
<dt class="sig sig-object py" id="cbcbeat.bidomainsolver.BasicBidomainSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cbcbeat.bidomainsolver.</span></span><span class="sig-name descname"><span class="pre">BasicBidomainSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M_e</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I_s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I_a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/bidomainsolver.html#BasicBidomainSolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.bidomainsolver.BasicBidomainSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This solver is based on a theta-scheme discretization in time
and CG_1 x CG_1 (x R) elements in space.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the sake of simplicity and consistency with other solver
objects, this solver operates on its solution fields (as state
variables) directly internally. More precisely, solve (and
step) calls will act by updating the internal solution
fields. It implies that initial conditions can be set (and are
intended to be set) by modifying the solution fields prior to
simulation.</p>
</div>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>mesh (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Mesh</span></code>)</dt><dd><p>The spatial domain (mesh)</p>
</dd>
<dt>time (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Constant</span></code> or None)</dt><dd><p>A constant holding the current time. If None is given, time is
created for you, initialized to zero.</p>
</dd>
<dt>M_i (<code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Expr</span></code>)</dt><dd><p>The intracellular conductivity tensor (as an UFL expression)</p>
</dd>
<dt>M_e (<code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Expr</span></code>)</dt><dd><p>The extracellular conductivity tensor (as an UFL expression)</p>
</dd>
<dt>I_s (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>, optional)</dt><dd><p>A typically time-dependent external stimulus given as a dict,
with domain markers as the key and a
<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Expression</span></code> as values. NB: it is assumed
that the time dependence of I_s is encoded via the ‘time’
Constant.</p>
</dd>
<dt>I_a (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Expression</span></code>, optional)</dt><dd><p>A (typically time-dependent) external applied current</p>
</dd>
<dt>v_ (<code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Expr</span></code>, optional)</dt><dd><p>Initial condition for v. A new <code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Function</span></code>
will be created if none is given.</p>
</dd>
<dt>params (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Parameters</span></code>, optional)</dt><dd><p>Solver parameters</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.bidomainsolver.BasicBidomainSolver.default_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">default_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/bidomainsolver.html#BasicBidomainSolver.default_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.bidomainsolver.BasicBidomainSolver.default_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize and return a set of default parameters</p>
<dl class="simple">
<dt><em>Returns</em></dt><dd><p>A set of parameters (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Parameters</span></code>)</p>
</dd>
</dl>
<p>To inspect all the default parameters, do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">info</span><span class="p">(</span><span class="n">BasicBidomainSolver</span><span class="o">.</span><span class="n">default_parameters</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.bidomainsolver.BasicBidomainSolver.solution_fields">
<span class="sig-name descname"><span class="pre">solution_fields</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/bidomainsolver.html#BasicBidomainSolver.solution_fields"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.bidomainsolver.BasicBidomainSolver.solution_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Return tuple of previous and current solution objects.</p>
<p>Modifying these will modify the solution objects of the solver
and thus provides a way for setting initial conditions for
instance.</p>
<dl class="simple">
<dt><em>Returns</em></dt><dd><p>(previous v, current vur) (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Function</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.bidomainsolver.BasicBidomainSolver.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/bidomainsolver.html#BasicBidomainSolver.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.bidomainsolver.BasicBidomainSolver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the discretization on a given time interval (t0, t1)
with a given timestep dt and return generator for a tuple of
the interval and the current solution.</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>interval (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>)</dt><dd><p>The time interval for the solve given by (t0, t1)</p>
</dd>
<dt>dt (int, optional)</dt><dd><p>The timestep for the solve. Defaults to length of interval</p>
</dd>
</dl>
</dd>
<dt><em>Returns</em></dt><dd><p>(timestep, solution_fields) via (<code class="xref py py-class docutils literal notranslate"><span class="pre">genexpr</span></code>)</p>
</dd>
</dl>
<p><em>Example of usage</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create generator</span>
<span class="n">solutions</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Iterate over generator (computes solutions as you go)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">solution_fields</span><span class="p">)</span> <span class="ow">in</span> <span class="n">solutions</span><span class="p">:</span>
  <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">)</span> <span class="o">=</span> <span class="n">interval</span>
  <span class="n">v_</span><span class="p">,</span> <span class="n">vur</span> <span class="o">=</span> <span class="n">solution_fields</span>
  <span class="c1"># do something with the solutions</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.bidomainsolver.BasicBidomainSolver.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/bidomainsolver.html#BasicBidomainSolver.step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.bidomainsolver.BasicBidomainSolver.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve on the given time interval (t0, t1).</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>interval (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>)</dt><dd><p>The time interval (t0, t1) for the step</p>
</dd>
</dl>
</dd>
<dt><em>Invariants</em></dt><dd><p>Assuming that v_ is in the correct state for t0, gives
self.vur in correct state at t1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cbcbeat.bidomainsolver.BasicBidomainSolver.time">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">time</span></span><a class="headerlink" href="#cbcbeat.bidomainsolver.BasicBidomainSolver.time" title="Permalink to this definition">¶</a></dt>
<dd><p>The internal time of the solver.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cbcbeat.bidomainsolver.BidomainSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cbcbeat.bidomainsolver.</span></span><span class="sig-name descname"><span class="pre">BidomainSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M_e</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I_s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I_a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/bidomainsolver.html#BidomainSolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.bidomainsolver.BidomainSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cbcbeat.bidomainsolver.BasicBidomainSolver" title="cbcbeat.bidomainsolver.BasicBidomainSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">cbcbeat.bidomainsolver.BasicBidomainSolver</span></code></a></p>
<p>This solver is based on a theta-scheme discretization in time
and CG_1 x CG_1 (x R) elements in space.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the sake of simplicity and consistency with other solver
objects, this solver operates on its solution fields (as state
variables) directly internally. More precisely, solve (and
step) calls will act by updating the internal solution
fields. It implies that initial conditions can be set (and are
intended to be set) by modifying the solution fields prior to
simulation.</p>
</div>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>mesh (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Mesh</span></code>)</dt><dd><p>The spatial domain (mesh)</p>
</dd>
<dt>time (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Constant</span></code> or None)</dt><dd><p>A constant holding the current time. If None is given, time is
created for you, initialized to zero.</p>
</dd>
<dt>M_i (<code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Expr</span></code>)</dt><dd><p>The intracellular conductivity tensor (as an UFL expression)</p>
</dd>
<dt>M_e (<code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Expr</span></code>)</dt><dd><p>The extracellular conductivity tensor (as an UFL expression)</p>
</dd>
<dt>I_s (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>, optional)</dt><dd><p>A typically time-dependent external stimulus given as a dict,
with domain markers as the key and a
<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Expression</span></code> as values. NB: it is assumed
that the time dependence of I_s is encoded via the ‘time’
Constant.</p>
</dd>
<dt>I_a (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Expression</span></code>, optional)</dt><dd><p>A (typically time-dependent) external applied current</p>
</dd>
<dt>v_ (<code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Expr</span></code>, optional)</dt><dd><p>Initial condition for v. A new <code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Function</span></code>
will be created if none is given.</p>
</dd>
<dt>params (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Parameters</span></code>, optional)</dt><dd><p>Solver parameters</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.bidomainsolver.BidomainSolver.default_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">default_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/bidomainsolver.html#BidomainSolver.default_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.bidomainsolver.BidomainSolver.default_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize and return a set of default parameters</p>
<dl class="simple">
<dt><em>Returns</em></dt><dd><p>A set of parameters (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Parameters</span></code>)</p>
</dd>
</dl>
<p>To inspect all the default parameters, do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">info</span><span class="p">(</span><span class="n">BidomainSolver</span><span class="o">.</span><span class="n">default_parameters</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cbcbeat.bidomainsolver.BidomainSolver.linear_solver">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">linear_solver</span></span><a class="headerlink" href="#cbcbeat.bidomainsolver.BidomainSolver.linear_solver" title="Permalink to this definition">¶</a></dt>
<dd><p>The linear solver (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.LUSolver</span></code> or
<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.PETScKrylovSolver</span></code>).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cbcbeat.bidomainsolver.BidomainSolver.nullspace">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nullspace</span></span><a class="headerlink" href="#cbcbeat.bidomainsolver.BidomainSolver.nullspace" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.bidomainsolver.BidomainSolver.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/bidomainsolver.html#BidomainSolver.step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.bidomainsolver.BidomainSolver.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve on the given time step (t0, t1).</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>interval (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>)</dt><dd><p>The time interval (t0, t1) for the step</p>
</dd>
</dl>
</dd>
<dt><em>Invariants</em></dt><dd><p>Assuming that v_ is in the correct state for t0, gives
self.vur in correct state at t1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.bidomainsolver.BidomainSolver.variational_forms">
<span class="sig-name descname"><span class="pre">variational_forms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k_n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/bidomainsolver.html#BidomainSolver.variational_forms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.bidomainsolver.BidomainSolver.variational_forms" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the variational forms corresponding to the given
discretization of the given system of equations.</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>k_n (<code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Expr</span></code> or float)</dt><dd><p>The time step</p>
</dd>
</dl>
</dd>
<dt><em>Returns</em></dt><dd><p>(lhs, rhs) (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Form</span></code>)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cbcbeat.cardiacmodels">
<span id="cbcbeat-cardiacmodels-module"></span><h2><span class="section-number">1.4. </span>cbcbeat.cardiacmodels module<a class="headerlink" href="#module-cbcbeat.cardiacmodels" title="Permalink to this headline">¶</a></h2>
<p>This module contains a container class for cardiac models:
<a class="reference internal" href="#cbcbeat.cardiacmodels.CardiacModel" title="cbcbeat.cardiacmodels.CardiacModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CardiacModel</span></code></a>.  This class
should be instantiated for setting up specific cardiac simulation
scenarios.</p>
<dl class="py class">
<dt class="sig sig-object py" id="cbcbeat.cardiacmodels.CardiacModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cbcbeat.cardiacmodels.</span></span><span class="sig-name descname"><span class="pre">CardiacModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M_e</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_models</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stimulus</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">applied_current</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cardiacmodels.html#CardiacModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cardiacmodels.CardiacModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A container class for cardiac models. Objects of this class
represent a specific cardiac simulation set-up and should provide</p>
<ul class="simple">
<li><p>A computational domain</p></li>
<li><p>A cardiac cell model</p></li>
<li><p>Intra-cellular and extra-cellular conductivities</p></li>
<li><p>Various forms of stimulus (optional).</p></li>
</ul>
<p>This container class is designed for use with the splitting
solvers (<a class="reference internal" href="#module-cbcbeat.splittingsolver" title="cbcbeat.splittingsolver"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cbcbeat.splittingsolver</span></code></a>), see their
documentation for more information on how the attributes are
interpreted in that context.</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>domain (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Mesh</span></code>)</dt><dd><p>the computational domain in space</p>
</dd>
<dt>time (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Constant</span></code> or None )</dt><dd><p>A constant holding the current time.</p>
</dd>
<dt>M_i (<code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Expr</span></code>)</dt><dd><p>the intra-cellular conductivity as an ufl Expression</p>
</dd>
<dt>M_e (<code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Expr</span></code>)</dt><dd><p>the extra-cellular conductivity as an ufl Expression</p>
</dd>
<dt>cell_models (<a class="reference internal" href="cbcbeat.cellmodels.html#cbcbeat.cellmodels.cardiaccellmodel.CardiacCellModel" title="cbcbeat.cellmodels.cardiaccellmodel.CardiacCellModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CardiacCellModel</span></code></a>)</dt><dd><p>a cell model or a dict with cell models associated with a cell model domain</p>
</dd>
<dt>stimulus (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>, optional)</dt><dd><p>A typically time-dependent external stimulus given as a dict,
with domain markers as the key and a
<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Expression</span></code> as values. NB: it is assumed
that the time dependence of I_s is encoded via the ‘time’
Constant.</p>
</dd>
<dt>applied_current (<code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Expr</span></code>, optional)</dt><dd><p>an applied current as an ufl Expression</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.cardiacmodels.CardiacModel.applied_current">
<span class="sig-name descname"><span class="pre">applied_current</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cardiacmodels.html#CardiacModel.applied_current"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cardiacmodels.CardiacModel.applied_current" title="Permalink to this definition">¶</a></dt>
<dd><p>An applied current: used as a source in the elliptic bidomain equation</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.cardiacmodels.CardiacModel.cell_models">
<span class="sig-name descname"><span class="pre">cell_models</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cardiacmodels.html#CardiacModel.cell_models"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cardiacmodels.CardiacModel.cell_models" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cell models</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.cardiacmodels.CardiacModel.conductivities">
<span class="sig-name descname"><span class="pre">conductivities</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cardiacmodels.html#CardiacModel.conductivities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cardiacmodels.CardiacModel.conductivities" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the intracellular and extracellular conductivities
as a tuple of UFL Expressions.</p>
<p><em>Returns</em>
(M_i, M_e) (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Expr</span></code>)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.cardiacmodels.CardiacModel.domain">
<span class="sig-name descname"><span class="pre">domain</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cardiacmodels.html#CardiacModel.domain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cardiacmodels.CardiacModel.domain" title="Permalink to this definition">¶</a></dt>
<dd><p>The spatial domain (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Mesh</span></code>).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.cardiacmodels.CardiacModel.extracellular_conductivity">
<span class="sig-name descname"><span class="pre">extracellular_conductivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cardiacmodels.html#CardiacModel.extracellular_conductivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cardiacmodels.CardiacModel.extracellular_conductivity" title="Permalink to this definition">¶</a></dt>
<dd><p>The intracellular conductivity (<code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Expr</span></code>).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.cardiacmodels.CardiacModel.intracellular_conductivity">
<span class="sig-name descname"><span class="pre">intracellular_conductivity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cardiacmodels.html#CardiacModel.intracellular_conductivity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cardiacmodels.CardiacModel.intracellular_conductivity" title="Permalink to this definition">¶</a></dt>
<dd><p>The intracellular conductivity (<code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Expr</span></code>).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.cardiacmodels.CardiacModel.stimulus">
<span class="sig-name descname"><span class="pre">stimulus</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cardiacmodels.html#CardiacModel.stimulus"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cardiacmodels.CardiacModel.stimulus" title="Permalink to this definition">¶</a></dt>
<dd><p>A stimulus: used as a source in the parabolic bidomain equation</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.cardiacmodels.CardiacModel.time">
<span class="sig-name descname"><span class="pre">time</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cardiacmodels.html#CardiacModel.time"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cardiacmodels.CardiacModel.time" title="Permalink to this definition">¶</a></dt>
<dd><p>The current time (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Constant</span></code> or None).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cbcbeat.cellsolver">
<span id="cbcbeat-cellsolver-module"></span><h2><span class="section-number">1.5. </span>cbcbeat.cellsolver module<a class="headerlink" href="#module-cbcbeat.cellsolver" title="Permalink to this headline">¶</a></h2>
<p>This module contains solvers for (subclasses of) CardiacCellModel.</p>
<dl class="py class">
<dt class="sig sig-object py" id="cbcbeat.cellsolver.BasicCardiacODESolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cbcbeat.cellsolver.</span></span><span class="sig-name descname"><span class="pre">BasicCardiacODESolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I_s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cellsolver.html#BasicCardiacODESolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cellsolver.BasicCardiacODESolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A basic, non-optimised solver for systems of ODEs typically
encountered in cardiac applications of the form: find a scalar
field <span class="math notranslate nohighlight">\(v = v(x, t)\)</span> and a vector field <span class="math notranslate nohighlight">\(s = s(x, t)\)</span></p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}v_t = - I_{ion}(v, s) + I_s\\s_t = F(v, s)\end{aligned}\end{align} \]</div>
<p>where <span class="math notranslate nohighlight">\(I_{ion}\)</span> and <span class="math notranslate nohighlight">\(F\)</span> are given non-linear
functions, and <span class="math notranslate nohighlight">\(I_s\)</span> is some prescribed stimulus.</p>
<p>Here, this nonlinear ODE system is solved via a theta-scheme.  By
default theta=0.5, which corresponds to a Crank-Nicolson
scheme. This can be changed by modifying the solver parameters.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the sake of simplicity and consistency with other solver
objects, this solver operates on its solution fields (as state
variables) directly internally. More precisely, solve (and
step) calls will act by updating the internal solution
fields. It implies that initial conditions can be set (and are
intended to be set) by modifying the solution fields prior to
simulation.</p>
</div>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>mesh (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Mesh</span></code>)</dt><dd><p>The spatial domain (mesh)</p>
</dd>
<dt>time (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Constant</span></code> or None)</dt><dd><p>A constant holding the current time. If None is given, time is
created for you, initialized to zero.</p>
</dd>
<dt>model (<code class="xref py py-class docutils literal notranslate"><span class="pre">cbcbeat.CardiacCellModel</span></code>)</dt><dd><p>A representation of the cardiac cell model(s)</p>
</dd>
<dt>I_s (optional) A typically time-dependent external stimulus</dt><dd><p>given as a <code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.GenericFunction</span></code> or a
Markerwise. NB: it is assumed that the time dependence of I_s
is encoded via the ‘time’ Constant.</p>
</dd>
<dt>params (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Parameters</span></code>, optional)</dt><dd><p>Solver parameters</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.cellsolver.BasicCardiacODESolver.default_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">default_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cellsolver.html#BasicCardiacODESolver.default_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cellsolver.BasicCardiacODESolver.default_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize and return a set of default parameters</p>
<dl class="simple">
<dt><em>Returns</em></dt><dd><p>A set of parameters (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Parameters</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.cellsolver.BasicCardiacODESolver.solution_fields">
<span class="sig-name descname"><span class="pre">solution_fields</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cellsolver.html#BasicCardiacODESolver.solution_fields"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cellsolver.BasicCardiacODESolver.solution_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Return tuple of previous and current solution objects.</p>
<p>Modifying these will modify the solution objects of the solver
and thus provides a way for setting initial conditions for
instance.</p>
<dl class="simple">
<dt><em>Returns</em></dt><dd><p>(previous vs, current vs) (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Function</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.cellsolver.BasicCardiacODESolver.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cellsolver.html#BasicCardiacODESolver.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cellsolver.BasicCardiacODESolver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the problem given by the model on a given time interval
(t0, t1) with a given timestep dt and return generator for a
tuple of the interval and the current vs solution.</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>interval (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>)</dt><dd><p>The time interval for the solve given by (t0, t1)</p>
</dd>
<dt>dt (int, optional)</dt><dd><p>The timestep for the solve. Defaults to length of interval</p>
</dd>
</dl>
</dd>
<dt><em>Returns</em></dt><dd><p>(timestep, current vs) via (<code class="xref py py-class docutils literal notranslate"><span class="pre">genexpr</span></code>)</p>
</dd>
</dl>
<p><em>Example of usage</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create generator</span>
<span class="n">solutions</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Iterate over generator (computes solutions as you go)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">vs</span><span class="p">)</span> <span class="ow">in</span> <span class="n">solutions</span><span class="p">:</span>
  <span class="c1"># do something with the solutions</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.cellsolver.BasicCardiacODESolver.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cellsolver.html#BasicCardiacODESolver.step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cellsolver.BasicCardiacODESolver.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve on the given time step (t0, t1).</p>
<p>End users are recommended to use solve instead.</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>interval (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>)</dt><dd><p>The time interval (t0, t1) for the step</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cbcbeat.cellsolver.BasicCardiacODESolver.time">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">time</span></span><a class="headerlink" href="#cbcbeat.cellsolver.BasicCardiacODESolver.time" title="Permalink to this definition">¶</a></dt>
<dd><p>The internal time of the solver.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cbcbeat.cellsolver.BasicSingleCellSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cbcbeat.cellsolver.</span></span><span class="sig-name descname"><span class="pre">BasicSingleCellSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cellsolver.html#BasicSingleCellSolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cellsolver.BasicSingleCellSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cbcbeat.cellsolver.BasicCardiacODESolver" title="cbcbeat.cellsolver.BasicCardiacODESolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">cbcbeat.cellsolver.BasicCardiacODESolver</span></code></a></p>
<p>A basic, non-optimised solver for systems of ODEs typically
encountered in cardiac applications of the form: find a scalar
field <span class="math notranslate nohighlight">\(v = v(t)\)</span> and a vector field <span class="math notranslate nohighlight">\(s = s(t)\)</span></p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}v_t = - I_{ion}(v, s) + I_s\\s_t = F(v, s)\end{aligned}\end{align} \]</div>
<p>where <span class="math notranslate nohighlight">\(I_{ion}\)</span> and <span class="math notranslate nohighlight">\(F\)</span> are given non-linear
functions, <span class="math notranslate nohighlight">\(I_s\)</span> is some prescribed stimulus. If <span class="math notranslate nohighlight">\(I_s\)</span>
depends on time, it is assumed that <span class="math notranslate nohighlight">\(I_s\)</span> is a
<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Expression</span></code> with parameter ‘t’.</p>
<p>Use this solver if you just want to test the results from a
cardiac cell model without any spatial mesh dependence.</p>
<p>Here, this nonlinear ODE system is solved via a theta-scheme.  By
default theta=0.5, which corresponds to a Crank-Nicolson
scheme. This can be changed by modifying the solver parameters.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the sake of simplicity and consistency with other solver
objects, this solver operates on its solution fields (as state
variables) directly internally. More precisely, solve (and
step) calls will act by updating the internal solution
fields. It implies that initial conditions can be set (and are
intended to be set) by modifying the solution fields prior to
simulation.</p>
</div>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>model (<a class="reference internal" href="cbcbeat.cellmodels.html#cbcbeat.cellmodels.cardiaccellmodel.CardiacCellModel" title="cbcbeat.cellmodels.cardiaccellmodel.CardiacCellModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CardiacCellModel</span></code></a>)</dt><dd><p>A cardiac cell model</p>
</dd>
<dt>time (<code class="xref py py-class docutils literal notranslate"><span class="pre">Constant</span></code> or None)</dt><dd><p>A constant holding the current time.</p>
</dd>
<dt>params (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Parameters</span></code>, optional)</dt><dd><p>Solver parameters</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cbcbeat.cellsolver.CardiacODESolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cbcbeat.cellsolver.</span></span><span class="sig-name descname"><span class="pre">CardiacODESolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I_s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cellsolver.html#CardiacODESolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cellsolver.CardiacODESolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An optimised solver for systems of ODEs typically
encountered in cardiac applications of the form: find a scalar
field <span class="math notranslate nohighlight">\(v = v(x, t)\)</span> and a vector field <span class="math notranslate nohighlight">\(s = s(x, t)\)</span></p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}v_t = - I_{ion}(v, s) + I_s\\s_t = F(v, s)\end{aligned}\end{align} \]</div>
<p>where <span class="math notranslate nohighlight">\(I_{ion}\)</span> and <span class="math notranslate nohighlight">\(F\)</span> are given non-linear
functions, and <span class="math notranslate nohighlight">\(I_s\)</span> is some prescribed stimulus.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the sake of simplicity and consistency with other solver
objects, this solver operates on its solution fields (as state
variables) directly internally. More precisely, solve (and
step) calls will act by updating the internal solution
fields. It implies that initial conditions can be set (and are
intended to be set) by modifying the solution fields prior to
simulation.</p>
</div>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>mesh (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Mesh</span></code>)</dt><dd><p>The spatial mesh (mesh)</p>
</dd>
<dt>time (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Constant</span></code> or None)</dt><dd><p>A constant holding the current time. If None is given, time is
created for you, initialized to zero.</p>
</dd>
<dt>model (<code class="xref py py-class docutils literal notranslate"><span class="pre">cbcbeat.CardiacCellModel</span></code>)</dt><dd><p>A representation of the cardiac cell model(s)</p>
</dd>
<dt>I_s (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Expression</span></code>, optional)</dt><dd><p>A typically time-dependent external stimulus. NB: it is
assumed that the time dependence of I_s is encoded via the
‘time’ Constant.</p>
</dd>
<dt>params (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Parameters</span></code>, optional)</dt><dd><p>Solver parameters</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.cellsolver.CardiacODESolver.default_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">default_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cellsolver.html#CardiacODESolver.default_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cellsolver.CardiacODESolver.default_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize and return a set of default parameters</p>
<dl class="simple">
<dt><em>Returns</em></dt><dd><p>A set of parameters (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Parameters</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.cellsolver.CardiacODESolver.solution_fields">
<span class="sig-name descname"><span class="pre">solution_fields</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cellsolver.html#CardiacODESolver.solution_fields"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cellsolver.CardiacODESolver.solution_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current solution object.</p>
<p>Modifying this will modify the solution object of the solver
and thus provides a way for setting initial conditions for
instance.</p>
<dl class="simple">
<dt><em>Returns</em></dt><dd><p>(previous <a href="#id1"><span class="problematic" id="id2">vs_</span></a>, current vs) (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Function</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.cellsolver.CardiacODESolver.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cellsolver.html#CardiacODESolver.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cellsolver.CardiacODESolver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the problem given by the model on a given time interval
(t0, t1) with a given timestep dt and return generator for a
tuple of the interval and the current vs solution.</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>interval (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>)</dt><dd><p>The time interval for the solve given by (t0, t1)</p>
</dd>
<dt>dt (int, optional)</dt><dd><p>The timestep for the solve. Defaults to length of interval</p>
</dd>
</dl>
</dd>
<dt><em>Returns</em></dt><dd><p>(timestep, current vs) via (<code class="xref py py-class docutils literal notranslate"><span class="pre">genexpr</span></code>)</p>
</dd>
</dl>
<p><em>Example of usage</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create generator</span>
<span class="n">solutions</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Iterate over generator (computes solutions as you go)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">vs</span><span class="p">)</span> <span class="ow">in</span> <span class="n">solutions</span><span class="p">:</span>
  <span class="c1"># do something with the solutions</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.cellsolver.CardiacODESolver.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cellsolver.html#CardiacODESolver.step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cellsolver.CardiacODESolver.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve on the given time step (t0, t1).</p>
<p>End users are recommended to use solve instead.</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>interval (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>)</dt><dd><p>The time interval (t0, t1) for the step</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cbcbeat.cellsolver.SingleCellSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cbcbeat.cellsolver.</span></span><span class="sig-name descname"><span class="pre">SingleCellSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/cellsolver.html#SingleCellSolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.cellsolver.SingleCellSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cbcbeat.cellsolver.CardiacODESolver" title="cbcbeat.cellsolver.CardiacODESolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">cbcbeat.cellsolver.CardiacODESolver</span></code></a></p>
</dd></dl>

</div>
<div class="section" id="module-cbcbeat.dolfinimport">
<span id="cbcbeat-dolfinimport-module"></span><h2><span class="section-number">1.6. </span>cbcbeat.dolfinimport module<a class="headerlink" href="#module-cbcbeat.dolfinimport" title="Permalink to this headline">¶</a></h2>
<p>This module handles all dolfin import in cbcbeat. Here dolfin and
dolfin_adjoint gets imported. If dolfin_adjoint is not present it will not
be imported.</p>
</div>
<div class="section" id="cbcbeat-gossplittingsolver-module">
<h2><span class="section-number">1.7. </span>cbcbeat.gossplittingsolver module<a class="headerlink" href="#cbcbeat-gossplittingsolver-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="cbcbeat-gotran2cellmodel-module">
<h2><span class="section-number">1.8. </span>cbcbeat.gotran2cellmodel module<a class="headerlink" href="#cbcbeat-gotran2cellmodel-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="cbcbeat-gotran2dolfin-module">
<h2><span class="section-number">1.9. </span>cbcbeat.gotran2dolfin module<a class="headerlink" href="#cbcbeat-gotran2dolfin-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-cbcbeat.markerwisefield">
<span id="cbcbeat-markerwisefield-module"></span><h2><span class="section-number">1.10. </span>cbcbeat.markerwisefield module<a class="headerlink" href="#module-cbcbeat.markerwisefield" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="cbcbeat.markerwisefield.Markerwise">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cbcbeat.markerwisefield.</span></span><span class="sig-name descname"><span class="pre">Markerwise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">objects</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">markers</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/markerwisefield.html#Markerwise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.markerwisefield.Markerwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A container class representing an object defined by a number of
objects combined with a mesh function defining mesh domains and a
map between the these.</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>objects (tuple)</dt><dd><p>the different objects</p>
</dd>
<dt>keys (tuple of ints)</dt><dd><p>a map from the objects to the domains marked in markers</p>
</dd>
<dt>markers (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.MeshFunction</span></code>)</dt><dd><p>a mesh function mapping which domains the mesh consist of</p>
</dd>
</dl>
</dd>
</dl>
<p><em>Example of usage</em></p>
<p>Given (g0, g1), (2, 5) and markers, let</p>
<blockquote>
<div><p>g = g0 on domains marked by 2 in markers
g = g1 on domains marked by 5 in markers</p>
</div></blockquote>
<p>letting:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="o">=</span> <span class="n">Markerwise</span><span class="p">((</span><span class="n">g0</span><span class="p">,</span> <span class="n">g1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">markers</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.markerwisefield.Markerwise.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/markerwisefield.html#Markerwise.keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.markerwisefield.Markerwise.keys" title="Permalink to this definition">¶</a></dt>
<dd><p>The keys or domain numbers</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.markerwisefield.Markerwise.markers">
<span class="sig-name descname"><span class="pre">markers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/markerwisefield.html#Markerwise.markers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.markerwisefield.Markerwise.markers" title="Permalink to this definition">¶</a></dt>
<dd><p>The markers</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.markerwisefield.Markerwise.values">
<span class="sig-name descname"><span class="pre">values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/markerwisefield.html#Markerwise.values"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.markerwisefield.Markerwise.values" title="Permalink to this definition">¶</a></dt>
<dd><p>The objects</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cbcbeat.markerwisefield.handle_markerwise">
<span class="sig-prename descclassname"><span class="pre">cbcbeat.markerwisefield.</span></span><span class="sig-name descname"><span class="pre">handle_markerwise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classtype</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/markerwisefield.html#handle_markerwise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.markerwisefield.handle_markerwise" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cbcbeat.markerwisefield.rhs_with_markerwise_field">
<span class="sig-prename descclassname"><span class="pre">cbcbeat.markerwisefield.</span></span><span class="sig-name descname"><span class="pre">rhs_with_markerwise_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/markerwisefield.html#rhs_with_markerwise_field"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.markerwisefield.rhs_with_markerwise_field" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-cbcbeat.monodomainsolver">
<span id="cbcbeat-monodomainsolver-module"></span><h2><span class="section-number">1.11. </span>cbcbeat.monodomainsolver module<a class="headerlink" href="#module-cbcbeat.monodomainsolver" title="Permalink to this headline">¶</a></h2>
<p>These solvers solve the (pure) monodomain equations on the form: find
the transmembrane potential <span class="math notranslate nohighlight">\(v = v(x, t)\)</span> such that</p>
<div class="math notranslate nohighlight">
\[v_t - \mathrm{div} ( G_i v) = I_s\]</div>
<p>where the subscript <span class="math notranslate nohighlight">\(t\)</span> denotes the time derivative; <span class="math notranslate nohighlight">\(G_i\)</span>
denotes a weighted gradient: <span class="math notranslate nohighlight">\(G_i = M_i \mathrm{grad}(v)\)</span> for,
where <span class="math notranslate nohighlight">\(M_i\)</span> is the intracellular cardiac conductivity tensor;
<span class="math notranslate nohighlight">\(I_s\)</span> ise prescribed input. In addition, initial conditions are
given for <span class="math notranslate nohighlight">\(v\)</span>:</p>
<div class="math notranslate nohighlight">
\[v(x, 0) = v_0\]</div>
<p>Finally, boundary conditions must be prescribed. For now, this solver
assumes pure homogeneous Neumann boundary conditions for <span class="math notranslate nohighlight">\(v\)</span>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="cbcbeat.monodomainsolver.BasicMonodomainSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cbcbeat.monodomainsolver.</span></span><span class="sig-name descname"><span class="pre">BasicMonodomainSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I_s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/monodomainsolver.html#BasicMonodomainSolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.monodomainsolver.BasicMonodomainSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This solver is based on a theta-scheme discretization in time
and CG_1 elements in space.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the sake of simplicity and consistency with other solver
objects, this solver operates on its solution fields (as state
variables) directly internally. More precisely, solve (and
step) calls will act by updating the internal solution
fields. It implies that initial conditions can be set (and are
intended to be set) by modifying the solution fields prior to
simulation.</p>
</div>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>mesh (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Mesh</span></code>)</dt><dd><p>The spatial domain (mesh)</p>
</dd>
<dt>time (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Constant</span></code> or None)</dt><dd><p>A constant holding the current time. If None is given, time is
created for you, initialized to zero.</p>
</dd>
<dt>M_i (<code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Expr</span></code>)</dt><dd><p>The intracellular conductivity tensor (as an UFL expression)</p>
</dd>
<dt>I_s (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>, optional)</dt><dd><p>A typically time-dependent external stimulus given as a dict,
with domain markers as the key and a
<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Expression</span></code> as values. NB: it is assumed
that the time dependence of I_s is encoded via the ‘time’
Constant.</p>
</dd>
<dt>v_ (<code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Expr</span></code>, optional)</dt><dd><p>Initial condition for v. A new <code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Function</span></code>
will be created if none is given.</p>
</dd>
<dt>params (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Parameters</span></code>, optional)</dt><dd><p>Solver parameters</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.monodomainsolver.BasicMonodomainSolver.default_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">default_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/monodomainsolver.html#BasicMonodomainSolver.default_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.monodomainsolver.BasicMonodomainSolver.default_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize and return a set of default parameters</p>
<dl class="simple">
<dt><em>Returns</em></dt><dd><p>A set of parameters (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Parameters</span></code>)</p>
</dd>
</dl>
<p>To inspect all the default parameters, do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">info</span><span class="p">(</span><span class="n">BasicMonodomainSolver</span><span class="o">.</span><span class="n">default_parameters</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.monodomainsolver.BasicMonodomainSolver.solution_fields">
<span class="sig-name descname"><span class="pre">solution_fields</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/monodomainsolver.html#BasicMonodomainSolver.solution_fields"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.monodomainsolver.BasicMonodomainSolver.solution_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Return tuple of previous and current solution objects.</p>
<p>Modifying these will modify the solution objects of the solver
and thus provides a way for setting initial conditions for
instance.</p>
<dl class="simple">
<dt><em>Returns</em></dt><dd><p>(previous v, current v) (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Function</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.monodomainsolver.BasicMonodomainSolver.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/monodomainsolver.html#BasicMonodomainSolver.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.monodomainsolver.BasicMonodomainSolver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the discretization on a given time interval (t0, t1)
with a given timestep dt and return generator for a tuple of
the interval and the current solution.</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>interval (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>)</dt><dd><p>The time interval for the solve given by (t0, t1)</p>
</dd>
<dt>dt (int, optional)</dt><dd><p>The timestep for the solve. Defaults to length of interval</p>
</dd>
</dl>
</dd>
<dt><em>Returns</em></dt><dd><p>(timestep, solution_field) via (<code class="xref py py-class docutils literal notranslate"><span class="pre">genexpr</span></code>)</p>
</dd>
</dl>
<p><em>Example of usage</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create generator</span>
<span class="n">solutions</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Iterate over generator (computes solutions as you go)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">solution_fields</span><span class="p">)</span> <span class="ow">in</span> <span class="n">solutions</span><span class="p">:</span>
  <span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">)</span> <span class="o">=</span> <span class="n">interval</span>
  <span class="n">v_</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">solution_fields</span>
  <span class="c1"># do something with the solutions</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.monodomainsolver.BasicMonodomainSolver.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/monodomainsolver.html#BasicMonodomainSolver.step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.monodomainsolver.BasicMonodomainSolver.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve on the given time interval (t0, t1).</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>interval (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>)</dt><dd><p>The time interval (t0, t1) for the step</p>
</dd>
</dl>
</dd>
<dt><em>Invariants</em></dt><dd><p>Assuming that v_ is in the correct state for t0, gives
self.v in correct state at t1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cbcbeat.monodomainsolver.BasicMonodomainSolver.time">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">time</span></span><a class="headerlink" href="#cbcbeat.monodomainsolver.BasicMonodomainSolver.time" title="Permalink to this definition">¶</a></dt>
<dd><p>The internal time of the solver.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cbcbeat.monodomainsolver.MonodomainSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cbcbeat.monodomainsolver.</span></span><span class="sig-name descname"><span class="pre">MonodomainSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I_s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/monodomainsolver.html#MonodomainSolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.monodomainsolver.MonodomainSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cbcbeat.monodomainsolver.BasicMonodomainSolver" title="cbcbeat.monodomainsolver.BasicMonodomainSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">cbcbeat.monodomainsolver.BasicMonodomainSolver</span></code></a></p>
<p>This solver is based on a theta-scheme discretization in time
and CG_1 elements in space.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the sake of simplicity and consistency with other solver
objects, this solver operates on its solution fields (as state
variables) directly internally. More precisely, solve (and
step) calls will act by updating the internal solution
fields. It implies that initial conditions can be set (and are
intended to be set) by modifying the solution fields prior to
simulation.</p>
</div>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>mesh (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Mesh</span></code>)</dt><dd><p>The spatial domain (mesh)</p>
</dd>
<dt>time (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Constant</span></code> or None)</dt><dd><p>A constant holding the current time. If None is given, time is
created for you, initialized to zero.</p>
</dd>
<dt>M_i (<code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Expr</span></code>)</dt><dd><p>The intracellular conductivity tensor (as an UFL expression)</p>
</dd>
<dt>I_s (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>, optional)</dt><dd><p>A typically time-dependent external stimulus given as a dict,
with domain markers as the key and a
<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Expression</span></code> as values. NB: it is assumed
that the time dependence of I_s is encoded via the ‘time’
Constant.</p>
</dd>
<dt>v_ (<code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Expr</span></code>, optional)</dt><dd><p>Initial condition for v. A new <code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Function</span></code>
will be created if none is given.</p>
</dd>
<dt>params (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Parameters</span></code>, optional)</dt><dd><p>Solver parameters</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.monodomainsolver.MonodomainSolver.default_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">default_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/monodomainsolver.html#MonodomainSolver.default_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.monodomainsolver.MonodomainSolver.default_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize and return a set of default parameters</p>
<dl class="simple">
<dt><em>Returns</em></dt><dd><p>A set of parameters (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Parameters</span></code>)</p>
</dd>
</dl>
<p>To inspect all the default parameters, do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">info</span><span class="p">(</span><span class="n">MonodomainSolver</span><span class="o">.</span><span class="n">default_parameters</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cbcbeat.monodomainsolver.MonodomainSolver.linear_solver">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">linear_solver</span></span><a class="headerlink" href="#cbcbeat.monodomainsolver.MonodomainSolver.linear_solver" title="Permalink to this definition">¶</a></dt>
<dd><p>The linear solver (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.LUSolver</span></code> or
<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.KrylovSolver</span></code>).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.monodomainsolver.MonodomainSolver.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/monodomainsolver.html#MonodomainSolver.step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.monodomainsolver.MonodomainSolver.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve on the given time step (t0, t1).</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>interval (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>)</dt><dd><p>The time interval (t0, t1) for the step</p>
</dd>
</dl>
</dd>
<dt><em>Invariants</em></dt><dd><p>Assuming that v_ is in the correct state for t0, gives
self.v in correct state at t1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.monodomainsolver.MonodomainSolver.variational_forms">
<span class="sig-name descname"><span class="pre">variational_forms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k_n</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/monodomainsolver.html#MonodomainSolver.variational_forms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.monodomainsolver.MonodomainSolver.variational_forms" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the variational forms corresponding to the given
discretization of the given system of equations.</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>k_n (<code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Expr</span></code> or float)</dt><dd><p>The time step</p>
</dd>
</dl>
</dd>
<dt><em>Returns</em></dt><dd><p>(lhs, rhs, prec) (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ufl.Form</span></code>)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cbcbeat.splittingsolver">
<span id="cbcbeat-splittingsolver-module"></span><h2><span class="section-number">1.12. </span>cbcbeat.splittingsolver module<a class="headerlink" href="#module-cbcbeat.splittingsolver" title="Permalink to this headline">¶</a></h2>
<p>This module contains splitting solvers for CardiacModel objects. In
particular, the classes</p>
<blockquote>
<div><ul class="simple">
<li><p>SplittingSolver</p></li>
<li><p>BasicSplittingSolver</p></li>
</ul>
</div></blockquote>
<p>These solvers solve the bidomain (or monodomain) equations on the
form: find the transmembrane potential <span class="math notranslate nohighlight">\(v = v(x, t)\)</span> in mV, the
extracellular potential <span class="math notranslate nohighlight">\(u = u(x, t)\)</span> in mV, and any additional
state variables <span class="math notranslate nohighlight">\(s = s(x, t)\)</span> such that</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}v_t - \mathrm{div} (M_i \mathrm{grad} v + M_i \mathrm{grad} u) = - I_{ion}(v, s) + I_s\\      \mathrm{div} (M_i \mathrm{grad} v + (M_i + M_e) \mathrm{grad} u) = I_a\\s_t = F(v, s)\end{aligned}\end{align} \]</div>
<p>where</p>
<blockquote>
<div><ul class="simple">
<li><p>the subscript <span class="math notranslate nohighlight">\(t\)</span> denotes the time derivative,</p></li>
<li><p><span class="math notranslate nohighlight">\(M_i\)</span> and <span class="math notranslate nohighlight">\(M_e\)</span> are conductivity tensors (in mm^2/ms)</p></li>
<li><p><span class="math notranslate nohighlight">\(I_s\)</span> is prescribed input current (in mV/ms)</p></li>
<li><p><span class="math notranslate nohighlight">\(I_a\)</span> is prescribed input current (in mV/ms)</p></li>
<li><p><span class="math notranslate nohighlight">\(I_{ion}\)</span> and <span class="math notranslate nohighlight">\(F\)</span> are typically specified by a cell model</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>Note that M_i and M_e can be viewed as scaled by <span class="math notranslate nohighlight">\(\chi*C_m\)</span> where</dt><dd><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\chi\)</span> is the surface-to volume ratio of cells (in 1/mm) ,</p></li>
<li><p><span class="math notranslate nohighlight">\(C_m\)</span> is the specific membrane capacitance (in mu F/(mm^2) ),</p></li>
</ul>
</dd>
</dl>
<p>In addition, initial conditions are given for <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(s\)</span>:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}v(x, 0) = v_0\\s(x, 0) = s_0\end{aligned}\end{align} \]</div>
<p>Finally, boundary conditions must be prescribed. These solvers assume
pure Neumann boundary conditions for <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(u\)</span> and
enforce the additional average value zero constraint for u.</p>
<p>The solvers take as input a
<a class="reference internal" href="#cbcbeat.cardiacmodels.CardiacModel" title="cbcbeat.cardiacmodels.CardiacModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CardiacModel</span></code></a> providing the
required input specification of the problem. In particular, the
applied current <span class="math notranslate nohighlight">\(I_a\)</span> is extracted from the
<a class="reference internal" href="#cbcbeat.cardiacmodels.CardiacModel.applied_current" title="cbcbeat.cardiacmodels.CardiacModel.applied_current"><code class="xref py py-attr docutils literal notranslate"><span class="pre">applied_current</span></code></a>
attribute, while the stimulus <span class="math notranslate nohighlight">\(I_s\)</span> is extracted from the
<a class="reference internal" href="#cbcbeat.cardiacmodels.CardiacModel.stimulus" title="cbcbeat.cardiacmodels.CardiacModel.stimulus"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stimulus</span></code></a> attribute.</p>
<p>It should be possible to use the solvers interchangably. However, note
that the BasicSplittingSolver is not optimised and should be used for
testing or debugging purposes primarily.</p>
<dl class="py class">
<dt class="sig sig-object py" id="cbcbeat.splittingsolver.BasicSplittingSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cbcbeat.splittingsolver.</span></span><span class="sig-name descname"><span class="pre">BasicSplittingSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/splittingsolver.html#BasicSplittingSolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.splittingsolver.BasicSplittingSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A non-optimised solver for the bidomain equations based on the
operator splitting scheme described in Sundnes et al 2006, p. 78
ff.</p>
<p>The solver computes as solutions:</p>
<blockquote>
<div><ul class="simple">
<li><p>“vs” (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Function</span></code>) representing the solution
for the transmembrane potential and any additional state
variables, and</p></li>
<li><p>“vur” (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Function</span></code>) representing the
transmembrane potential in combination with the extracellular
potential and an additional Lagrange multiplier.</p></li>
</ul>
</div></blockquote>
<p>The algorithm can be controlled by a number of parameters. In
particular, the splitting algorithm can be controlled by the
parameter “theta”: “theta” set to 1.0 corresponds to a (1st order)
Godunov splitting while “theta” set to 0.5 to a (2nd order) Strang
splitting.</p>
<p>This solver has not been optimised for computational efficiency
and should therefore primarily be used for debugging purposes. For
an equivalent, but more efficient, solver, see
<a class="reference internal" href="#cbcbeat.splittingsolver.SplittingSolver" title="cbcbeat.splittingsolver.SplittingSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">cbcbeat.splittingsolver.SplittingSolver</span></code></a>.</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>model (<a class="reference internal" href="#cbcbeat.cardiacmodels.CardiacModel" title="cbcbeat.cardiacmodels.CardiacModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">cbcbeat.cardiacmodels.CardiacModel</span></code></a>)</dt><dd><p>a CardiacModel object describing the simulation set-up</p>
</dd>
<dt>params (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Parameters</span></code>, optional)</dt><dd><p>a Parameters object controlling solver parameters</p>
</dd>
</dl>
</dd>
<dt><em>Assumptions</em></dt><dd><ul class="simple">
<li><p>The cardiac conductivities do not vary in time</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.splittingsolver.BasicSplittingSolver.default_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">default_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/splittingsolver.html#BasicSplittingSolver.default_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.splittingsolver.BasicSplittingSolver.default_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize and return a set of default parameters for the
splitting solver</p>
<dl class="simple">
<dt><em>Returns</em></dt><dd><p>A set of parameters (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Parameters</span></code>)</p>
</dd>
</dl>
<p>To inspect all the default parameters, do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">info</span><span class="p">(</span><span class="n">BasicSplittingSolver</span><span class="o">.</span><span class="n">default_parameters</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.splittingsolver.BasicSplittingSolver.merge">
<span class="sig-name descname"><span class="pre">merge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solution</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/splittingsolver.html#BasicSplittingSolver.merge"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.splittingsolver.BasicSplittingSolver.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine solutions from the PDE solve and the ODE solve to form
a single mixed function.</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>solution (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Function</span></code>)</dt><dd><p>Function holding the combined result</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.splittingsolver.BasicSplittingSolver.solution_fields">
<span class="sig-name descname"><span class="pre">solution_fields</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/splittingsolver.html#BasicSplittingSolver.solution_fields"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.splittingsolver.BasicSplittingSolver.solution_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Return tuple of previous and current solution objects.</p>
<p>Modifying these will modify the solution objects of the solver
and thus provides a way for setting initial conditions for
instance.</p>
<dl class="simple">
<dt><em>Returns</em></dt><dd><p>(previous vs, current vs, current vur) (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Function</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.splittingsolver.BasicSplittingSolver.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/splittingsolver.html#BasicSplittingSolver.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.splittingsolver.BasicSplittingSolver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the problem given by the model on a given time interval
(t0, t1) with a given timestep dt and return generator for a
tuple of the time step and the solution fields.</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>interval (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>)</dt><dd><p>The time interval for the solve given by (t0, t1)</p>
</dd>
<dt>dt (int, list of tuples of floats)</dt><dd><p>The timestep for the solve. A list of tuples of floats can
also be passed. Each tuple should contain two floats where the
first includes the start time and the second the dt.</p>
</dd>
</dl>
</dd>
<dt><em>Returns</em></dt><dd><p>(timestep, solution_fields) via (<code class="xref py py-class docutils literal notranslate"><span class="pre">genexpr</span></code>)</p>
</dd>
</dl>
<p><em>Example of usage</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create generator</span>
<span class="n">dts</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">),</span> <span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)]</span>
<span class="n">solutions</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">dts</span><span class="p">)</span>

<span class="c1"># Iterate over generator (computes solutions as you go)</span>
<span class="k">for</span> <span class="p">((</span><span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">),</span> <span class="p">(</span><span class="n">vs_</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">vur</span><span class="p">))</span> <span class="ow">in</span> <span class="n">solutions</span><span class="p">:</span>
  <span class="c1"># do something with the solutions</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.splittingsolver.BasicSplittingSolver.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/splittingsolver.html#BasicSplittingSolver.step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.splittingsolver.BasicSplittingSolver.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the problem given by the model on a given time interval
(t0, t1) with timestep given by the interval length.</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>interval (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>)</dt><dd><p>The time interval for the solve given by (t0, t1)</p>
</dd>
</dl>
</dd>
<dt><em>Invariants</em></dt><dd><p>Given self._vs in a correct state at t0, provide v and s (in
self.vs) and u (in self.vur) in a correct state at t1. (Note
that self.vur[0] == self.vs[0] only if theta = 1.0.)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cbcbeat.splittingsolver.SplittingSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cbcbeat.splittingsolver.</span></span><span class="sig-name descname"><span class="pre">SplittingSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/splittingsolver.html#SplittingSolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.splittingsolver.SplittingSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cbcbeat.splittingsolver.BasicSplittingSolver" title="cbcbeat.splittingsolver.BasicSplittingSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">cbcbeat.splittingsolver.BasicSplittingSolver</span></code></a></p>
<p>An optimised solver for the bidomain equations based on the
operator splitting scheme described in Sundnes et al 2006, p. 78
ff.</p>
<p>The solver computes as solutions:</p>
<blockquote>
<div><ul class="simple">
<li><p>“vs” (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Function</span></code>) representing the solution
for the transmembrane potential and any additional state
variables, and</p></li>
<li><p>“vur” (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Function</span></code>) representing the
transmembrane potential in combination with the extracellular
potential and an additional Lagrange multiplier.</p></li>
</ul>
</div></blockquote>
<p>The algorithm can be controlled by a number of parameters. In
particular, the splitting algorithm can be controlled by the
parameter “theta”: “theta” set to 1.0 corresponds to a (1st order)
Godunov splitting while “theta” set to 0.5 to a (2nd order) Strang
splitting.</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>model (<a class="reference internal" href="#cbcbeat.cardiacmodels.CardiacModel" title="cbcbeat.cardiacmodels.CardiacModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">cbcbeat.cardiacmodels.CardiacModel</span></code></a>)</dt><dd><p>a CardiacModel object describing the simulation set-up</p>
</dd>
<dt>params (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Parameters</span></code>, optional)</dt><dd><p>a Parameters object controlling solver parameters</p>
</dd>
</dl>
</dd>
</dl>
<p><em>Example of usage</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cbcbeat</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Describe the cardiac model</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">time</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">cell_model</span> <span class="o">=</span> <span class="n">FitzHughNagumoManual</span><span class="p">()</span>
<span class="n">stimulus</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s2">&quot;10*t*x[0]&quot;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">cm</span> <span class="o">=</span> <span class="n">CardiacModel</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">cell_model</span><span class="p">,</span> <span class="n">stimulus</span><span class="p">)</span>

<span class="c1"># Extract default solver parameters</span>
<span class="n">ps</span> <span class="o">=</span> <span class="n">SplittingSolver</span><span class="o">.</span><span class="n">default_parameters</span><span class="p">()</span>

<span class="c1"># Examine the default parameters</span>
<span class="n">info</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># Update parameter dictionary</span>
<span class="n">ps</span><span class="p">[</span><span class="s2">&quot;theta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># Use first order splitting</span>
<span class="n">ps</span><span class="p">[</span><span class="s2">&quot;CardiacODESolver&quot;</span><span class="p">][</span><span class="s2">&quot;scheme&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;GRL1&quot;</span> <span class="c1"># Use Generalized Rush-Larsen scheme</span>

<span class="n">ps</span><span class="p">[</span><span class="s2">&quot;pde_solver&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;monodomain&quot;</span>                         <span class="c1"># Use monodomain equations as the PDE model</span>
<span class="n">ps</span><span class="p">[</span><span class="s2">&quot;MonodomainSolver&quot;</span><span class="p">][</span><span class="s2">&quot;linear_solver_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;direct&quot;</span> <span class="c1"># Use direct linear solver of the PDEs</span>
<span class="n">ps</span><span class="p">[</span><span class="s2">&quot;MonodomainSolver&quot;</span><span class="p">][</span><span class="s2">&quot;theta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>                   <span class="c1"># Use backward Euler for temporal discretization for the PDEs</span>

<span class="n">solver</span> <span class="o">=</span> <span class="n">SplittingSolver</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">ps</span><span class="p">)</span>

<span class="c1"># Extract the solution fields and set the initial conditions</span>
<span class="p">(</span><span class="n">vs_</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">vur</span><span class="p">)</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solution_fields</span><span class="p">()</span>
<span class="n">vs_</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">cell_model</span><span class="o">.</span><span class="n">initial_conditions</span><span class="p">())</span>

<span class="c1"># Solve</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">T</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">interval</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">fields</span><span class="p">)</span> <span class="ow">in</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="p">(</span><span class="n">vs_</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">vur</span><span class="p">)</span> <span class="o">=</span> <span class="n">fields</span>
    <span class="c1"># Do something with the solutions</span>
</pre></div>
</div>
<dl class="simple">
<dt><em>Assumptions</em></dt><dd><ul class="simple">
<li><p>The cardiac conductivities do not vary in time</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.splittingsolver.SplittingSolver.default_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">default_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/splittingsolver.html#SplittingSolver.default_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.splittingsolver.SplittingSolver.default_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize and return a set of default parameters for the
splitting solver</p>
<dl class="simple">
<dt><em>Returns</em></dt><dd><p>The set of default parameters (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Parameters</span></code>)</p>
</dd>
</dl>
<p><em>Example of usage</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">info</span><span class="p">(</span><span class="n">SplittingSolver</span><span class="o">.</span><span class="n">default_parameters</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cbcbeat.utils">
<span id="cbcbeat-utils-module"></span><h2><span class="section-number">1.13. </span>cbcbeat.utils module<a class="headerlink" href="#module-cbcbeat.utils" title="Permalink to this headline">¶</a></h2>
<p>This module provides various utilities for internal use.</p>
<dl class="py class">
<dt class="sig sig-object py" id="cbcbeat.utils.Projecter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cbcbeat.utils.</span></span><span class="sig-name descname"><span class="pre">Projecter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/utils.html#Projecter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.utils.Projecter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Customized class for repeated projection.</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>V (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.FunctionSpace</span></code>)</dt><dd><p>The function space to project into</p>
</dd>
<dt>solver_type (string, optional)</dt><dd><p>“iterative” (default) or “direct”</p>
</dd>
</dl>
</dd>
<dt><em>Example of usage</em>::</dt><dd><p>my_project = Projecter(V, solver_type=”direct”)
u = Function(V)
f = Function(W)
my_project(f, u)</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="cbcbeat.utils.Projecter.default_parameters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">default_parameters</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/utils.html#Projecter.default_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.utils.Projecter.default_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cbcbeat.utils.convergence_rate">
<span class="sig-prename descclassname"><span class="pre">cbcbeat.utils.</span></span><span class="sig-name descname"><span class="pre">convergence_rate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/utils.html#convergence_rate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.utils.convergence_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute and return rates of convergence <span class="math notranslate nohighlight">\(r_i\)</span> such that</p>
<div class="math notranslate nohighlight">
\[errors = C hs^r\]</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cbcbeat.utils.end_of_time">
<span class="sig-prename descclassname"><span class="pre">cbcbeat.utils.</span></span><span class="sig-name descname"><span class="pre">end_of_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/utils.html#end_of_time"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.utils.end_of_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the interval (t0, t1) is the last before the end
time T, otherwise False.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cbcbeat.utils.state_space">
<span class="sig-prename descclassname"><span class="pre">cbcbeat.utils.</span></span><span class="sig-name descname"><span class="pre">state_space</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cbcbeat/utils.html#state_space"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cbcbeat.utils.state_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Return function space for the state variables.</p>
<dl class="simple">
<dt><em>Arguments</em></dt><dd><dl class="simple">
<dt>domain (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.Mesh</span></code>)</dt><dd><p>The computational domain</p>
</dd>
<dt>d (int)</dt><dd><p>The number of states</p>
</dd>
<dt>family (string, optional)</dt><dd><p>The finite element family, defaults to “CG” if None is given.</p>
</dd>
<dt>k (int, optional)</dt><dd><p>The finite element degree, defaults to 1</p>
</dd>
</dl>
</dd>
<dt><em>Returns</em></dt><dd><p>a function space (<code class="xref py py-class docutils literal notranslate"><span class="pre">dolfin.FunctionSpace</span></code>)</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-cbcbeat">
<span id="module-contents"></span><h2><span class="section-number">1.14. </span>Module contents<a class="headerlink" href="#module-cbcbeat" title="Permalink to this headline">¶</a></h2>
<p>The cbcbeat Python module is a problem and solver collection for
cardiac electrophysiology models.</p>
<p>To import the module, type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cbcbeat</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
</div>
</div>


              </div>
              
        
            <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="index.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">cbcbeat: an adjoint-enabled framework for computational cardiac electrophysiology</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="cbcbeat.cellmodels.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">1.1.1. </span>cbcbeat.cellmodels package</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
            &copy; Copyright 2014--2017, ME Rognes, J Hake, PE Farrell, SW Funke.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>